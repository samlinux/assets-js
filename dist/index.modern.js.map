{"version":3,"file":"index.modern.js","sources":["../src/did/asset_canister.did.js","../src/index.ts","../src/did/index.js"],"sourcesContent":["export const idlFactory = ({IDL}) => {\r\n    const ClearArguments = IDL.Record({});\r\n    const BatchId = IDL.Nat;\r\n    const Key = IDL.Text;\r\n    const CreateAssetArguments = IDL.Record({\r\n        'key': Key,\r\n        'content_type': IDL.Text,\r\n    });\r\n    const UnsetAssetContentArguments = IDL.Record({\r\n        'key': Key,\r\n        'content_encoding': IDL.Text,\r\n    });\r\n    const DeleteAssetArguments = IDL.Record({'key': Key});\r\n    const ChunkId = IDL.Nat;\r\n    const SetAssetContentArguments = IDL.Record({\r\n        'key': Key,\r\n        'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\r\n        'chunk_ids': IDL.Vec(ChunkId),\r\n        'content_encoding': IDL.Text,\r\n    });\r\n    const BatchOperationKind = IDL.Variant({\r\n        'CreateAsset': CreateAssetArguments,\r\n        'UnsetAssetContent': UnsetAssetContentArguments,\r\n        'DeleteAsset': DeleteAssetArguments,\r\n        'SetAssetContent': SetAssetContentArguments,\r\n        'Clear': ClearArguments,\r\n    });\r\n    const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);\r\n    const HttpRequest = IDL.Record({\r\n        'url': IDL.Text,\r\n        'method': IDL.Text,\r\n        'body': IDL.Vec(IDL.Nat8),\r\n        'headers': IDL.Vec(HeaderField),\r\n    });\r\n    const StreamingCallbackToken = IDL.Record({\r\n        'key': Key,\r\n        'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\r\n        'index': IDL.Nat,\r\n        'content_encoding': IDL.Text,\r\n    });\r\n    const StreamingCallbackHttpResponse = IDL.Record({\r\n        'token': IDL.Opt(StreamingCallbackToken),\r\n        'body': IDL.Vec(IDL.Nat8),\r\n    });\r\n    const StreamingStrategy = IDL.Variant({\r\n        'Callback': IDL.Record({\r\n            'token': StreamingCallbackToken,\r\n            'callback': IDL.Func(\r\n                [StreamingCallbackToken],\r\n                [IDL.Opt(StreamingCallbackHttpResponse)],\r\n                ['query'],\r\n            ),\r\n        }),\r\n    });\r\n    const HttpResponse = IDL.Record({\r\n        'body': IDL.Vec(IDL.Nat8),\r\n        'headers': IDL.Vec(HeaderField),\r\n        'streaming_strategy': IDL.Opt(StreamingStrategy),\r\n        'status_code': IDL.Nat16,\r\n    });\r\n    const Time = IDL.Int;\r\n    return IDL.Service({\r\n        'authorize': IDL.Func([IDL.Principal], [], []),\r\n        'clear': IDL.Func([ClearArguments], [], []),\r\n        'commit_batch': IDL.Func(\r\n            [\r\n                IDL.Record({\r\n                    'batch_id': BatchId,\r\n                    'operations': IDL.Vec(BatchOperationKind),\r\n                }),\r\n            ],\r\n            [],\r\n            [],\r\n        ),\r\n        'create_asset': IDL.Func([CreateAssetArguments], [], []),\r\n        'create_batch': IDL.Func(\r\n            [IDL.Record({})],\r\n            [IDL.Record({'batch_id': BatchId})],\r\n            [],\r\n        ),\r\n        'create_chunk': IDL.Func(\r\n            [IDL.Record({'content': IDL.Vec(IDL.Nat8), 'batch_id': BatchId})],\r\n            [IDL.Record({'chunk_id': ChunkId})],\r\n            [],\r\n        ),\r\n        'delete_content': IDL.Func([DeleteAssetArguments], [], []),\r\n        'get': IDL.Func(\r\n            [IDL.Record({'key': Key, 'accept_encodings': IDL.Vec(IDL.Text)})],\r\n            [\r\n                IDL.Record({\r\n                    'content': IDL.Vec(IDL.Nat8),\r\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\r\n                    'content_type': IDL.Text,\r\n                    'content_encoding': IDL.Text,\r\n                    'total_length': IDL.Nat,\r\n                }),\r\n            ],\r\n            ['query'],\r\n        ),\r\n        'get_chunk': IDL.Func(\r\n            [\r\n                IDL.Record({\r\n                    'key': Key,\r\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\r\n                    'index': IDL.Nat,\r\n                    'content_encoding': IDL.Text,\r\n                }),\r\n            ],\r\n            [IDL.Record({'content': IDL.Vec(IDL.Nat8)})],\r\n            ['query'],\r\n        ),\r\n        'http_request': IDL.Func([HttpRequest], [HttpResponse], ['query']),\r\n        'http_request_streaming_callback': IDL.Func(\r\n            [StreamingCallbackToken],\r\n            [IDL.Opt(StreamingCallbackHttpResponse)],\r\n            ['query'],\r\n        ),\r\n        'list': IDL.Func(\r\n            [IDL.Record({})],\r\n            [\r\n                IDL.Vec(\r\n                    IDL.Record({\r\n                        'key': Key,\r\n                        'encodings': IDL.Vec(\r\n                            IDL.Record({\r\n                                'modified': Time,\r\n                                'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\r\n                                'length': IDL.Nat,\r\n                                'content_encoding': IDL.Text,\r\n                            })\r\n                        ),\r\n                        'content_type': IDL.Text,\r\n                    })\r\n                ),\r\n            ],\r\n            ['query'],\r\n        ),\r\n        'set_asset_content': IDL.Func([SetAssetContentArguments], [], []),\r\n        'store': IDL.Func(\r\n            [\r\n                IDL.Record({\r\n                    'key': Key,\r\n                    'content': IDL.Vec(IDL.Nat8),\r\n                    'sha256': IDL.Opt(IDL.Vec(IDL.Nat8)),\r\n                    'content_type': IDL.Text,\r\n                    'content_encoding': IDL.Text,\r\n                }),\r\n            ],\r\n            [],\r\n            [],\r\n        ),\r\n        'unset_asset_content': IDL.Func([UnsetAssetContentArguments], [], []),\r\n    });\r\n};","import {ActorConfig} from \"@dfinity/agent\";\r\nimport {assetCanister} from \"./did\";\r\nimport {fileTypeFromBuffer} from \"file-type\";\r\nimport pLimit, {LimitFunction} from \"p-limit\";\r\n\r\ntype AssetCanister = ReturnType<typeof assetCanister>;\r\n\r\ninterface AssetManagerConfig extends ActorConfig {\r\n    concurrency?: number;\r\n    maxSingleFileSize?: number;\r\n    maxChunkSize?: number;\r\n    eventListener?: (event: AssetEvent) => void;\r\n}\r\n\r\ninterface Asset {\r\n    fileName: string;\r\n    path: string;\r\n    content: number[];\r\n    contentType: string;\r\n    contentEncoding: 'identity' | 'gzip' | 'compress' | 'deflate' | 'br';\r\n    sha256?: number[];\r\n}\r\n\r\ninterface AssetInsert {\r\n    (file: File, options?: Omit<Asset, 'fileName' | 'content' | 'contentEncoding'> & Partial<Pick<Asset, 'fileName' | 'contentEncoding'>>): Promise<string>;\r\n\r\n    (bytes: Blob | number[] | Uint8Array, options: Omit<Asset, 'content' | 'contentEncoding'> & Partial<Pick<Asset, 'contentEncoding'>>): Promise<string>;\r\n}\r\n\r\ninterface FileToAsset {\r\n    (...args: Parameters<AssetInsert>): Promise<Asset>;\r\n}\r\n\r\ninterface InsertAssetEvent {\r\n    key: string;\r\n    type: 'insert';\r\n    progress: {\r\n        current: number;\r\n        total: number;\r\n    };\r\n}\r\n\r\ninterface DeleteAssetEvent {\r\n    key: string;\r\n    type: 'delete';\r\n}\r\n\r\ntype AssetEvent = InsertAssetEvent | DeleteAssetEvent;\r\n\r\nconst isBrowser =\r\n    typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\r\n\r\nconst isNode =\r\n    typeof process !== \"undefined\" &&\r\n    process.versions != null &&\r\n    process.versions.node != null;\r\n\r\nconst isWebWorker =\r\n    typeof self === \"object\" &&\r\n    self.constructor &&\r\n    self.constructor.name === \"DedicatedWorkerGlobalScope\";\r\n\r\nconst crypto: Promise<any> = isBrowser\r\n    ? Promise.resolve(window.crypto)\r\n    : isWebWorker\r\n        ? Promise.resolve(self.crypto)\r\n        : isNode\r\n            ? import('crypto')\r\n            : Promise.resolve();\r\n\r\nconst hash = async (content: number[]): Promise<number[] | undefined> => {\r\n    if (isBrowser || isWebWorker) {\r\n        return Array.from(new Uint8Array(await (await crypto).subtle.digest('SHA-256', new Uint8Array(content))));\r\n    }\r\n    if (isNode) {\r\n        return Array.from((await crypto).createHash('sha256').update(new Uint8Array(content)).digest());\r\n    }\r\n}\r\n\r\nconst inputToAsset: FileToAsset = async (input, options) => {\r\n    let content: number[];\r\n    let fileName: string = options?.fileName as any;\r\n    let contentType: string = options?.contentType as any;\r\n    let path: string = options?.path ?? '/';\r\n    if (input instanceof Uint8Array) {\r\n        content = Array.from(input);\r\n    } else if (Array.isArray(input) && input.every(b => typeof b === 'number')) {\r\n        content = input;\r\n    } else if (input instanceof Blob) {\r\n        content = await new Promise((resolve) => {\r\n            const reader = new FileReader();\r\n            reader.addEventListener('load', () => {\r\n                resolve(Array.from(Uint8Array.from(reader.result as any)));\r\n            });\r\n            reader.readAsArrayBuffer(input);\r\n        });\r\n        if (!fileName) {\r\n            if (input instanceof File) {\r\n                fileName = input.name;\r\n            } else {\r\n                throw '\"fileName\" property is required in options';\r\n            }\r\n        }\r\n        if (!contentType) {\r\n            contentType = input.type;\r\n        }\r\n    } else {\r\n        throw 'Asset could not be read (File, Blob, ArrayBuffer, Uint8Array and number[] are valid';\r\n    }\r\n    if (!path.startsWith('/')) {\r\n        path = '/' + path;\r\n    }\r\n    if (!path.endsWith('/')) {\r\n        path = path + '/';\r\n    }\r\n    const contentEncoding = options?.contentEncoding ?? 'identity';\r\n    const sha256 = options?.sha256 ?? await hash(content);\r\n\r\n    // If content type is not supplied in either the file or options, detect content type based on magic number\r\n    if (!contentType) {\r\n        const {mime = 'application/octet-stream'} = await fileTypeFromBuffer(Uint8Array.from(content)) ?? {};\r\n        contentType = mime;\r\n    }\r\n\r\n    return {\r\n        fileName,\r\n        path,\r\n        content,\r\n        contentType,\r\n        contentEncoding,\r\n        sha256,\r\n    };\r\n};\r\n\r\nexport class AssetManager {\r\n    private readonly _actor: AssetCanister;\r\n    private readonly _pLimit: LimitFunction;\r\n    private readonly _maxSingleFileSize: number;\r\n    private readonly _maxChunkSize: number;\r\n    private readonly _eventListener: (event: AssetEvent) => void;\r\n\r\n    constructor({concurrency, maxSingleFileSize, maxChunkSize, eventListener, ...actorConfig}: AssetManagerConfig) {\r\n        this._actor = assetCanister(actorConfig);\r\n        this._pLimit = pLimit(concurrency ?? 32);\r\n        this._maxSingleFileSize = maxSingleFileSize ?? 450000;\r\n        this._maxChunkSize = maxChunkSize ?? 1900000;\r\n        this._eventListener = eventListener ?? (() => null);\r\n    }\r\n\r\n    list = () => this._pLimit(() => this._actor.list({}));\r\n\r\n    batch = () => {\r\n        const scheduledOperations: Array<(batch_id: bigint) => Promise<Parameters<AssetCanister['commit_batch']>[0]['operations']>> = [];\r\n        const commit = async () => {\r\n            const {batch_id} = await this._pLimit(() => this._actor.create_batch({}));\r\n            const operations = (await Promise.all(scheduledOperations.map(scheduled_operation => scheduled_operation(batch_id)))).flat();\r\n            await this._pLimit(() => this._actor.commit_batch({batch_id, operations}));\r\n            operations.forEach(operation => {\r\n                if ('DeleteAsset' in operation) {\r\n                    this._eventListener({key: operation.DeleteAsset.key, type: 'delete'});\r\n                }\r\n            })\r\n        };\r\n        const insert: AssetInsert = async (input, options) => {\r\n            const asset = await inputToAsset(input, options);\r\n            const key = [asset.path, asset.fileName].join('');\r\n            this._eventListener({key, type: 'insert', progress: {current: 0, total: asset.content.length}});\r\n            scheduledOperations.push(async batch_id => {\r\n                const chunks = asset.content.reduce((chunks, byte, index) => {\r\n                    const chunkIndex = Math.floor(index / this._maxChunkSize)\r\n                    if (!chunks[chunkIndex]) {\r\n                        chunks[chunkIndex] = [];\r\n                    }\r\n                    chunks[chunkIndex].push(byte)\r\n                    return chunks;\r\n                }, [] as number[][]);\r\n                let progress = 0;\r\n                const chunkIds: bigint[] = await Promise.all(chunks\r\n                    .map(async chunk => {\r\n                        const {chunk_id} = await this._pLimit(() => this._actor.create_chunk({\r\n                            content: chunk,\r\n                            batch_id\r\n                        }));\r\n                        progress += chunk.length;\r\n                        this._eventListener({\r\n                            key,\r\n                            type: 'insert',\r\n                            progress: {current: progress, total: asset.content.length}\r\n                        });\r\n                        return chunk_id;\r\n                    })\r\n                );\r\n                return [\r\n                    {\r\n                        CreateAsset: {key, content_type: asset.contentType}\r\n                    },\r\n                    {\r\n                        SetAssetContent: {\r\n                            key,\r\n                            sha256: asset.sha256 ? [asset.sha256] : [],\r\n                            chunk_ids: chunkIds,\r\n                            content_encoding: asset.contentEncoding\r\n                        }\r\n                    },\r\n                ];\r\n            });\r\n            return key;\r\n        }\r\n        const _delete = async (key: string) => {\r\n            scheduledOperations.push(async () => [{DeleteAsset: {key}}]);\r\n        }\r\n\r\n        return {commit, insert, delete: _delete};\r\n    }\r\n\r\n    insert: AssetInsert = async (input, options) => {\r\n        const asset = await inputToAsset(input, options);\r\n        const key = [asset.path, asset.fileName].join('');\r\n\r\n        if (asset.content.length <= this._maxSingleFileSize) {\r\n            // Asset is small enough to be uploaded in one request\r\n            this._eventListener({key, type: 'insert', progress: {current: 0, total: asset.content.length}});\r\n            await this._pLimit(() => this._actor.store({\r\n                key,\r\n                content: asset.content,\r\n                content_type: asset.contentType,\r\n                sha256: asset.sha256 ? [asset.sha256] : [],\r\n                content_encoding: asset.contentEncoding\r\n            }));\r\n        } else {\r\n            // Create batch to upload asset in chunks\r\n            const batch = this.batch();\r\n            await batch.insert(asset.content, asset);\r\n            await batch.commit();\r\n        }\r\n\r\n        return key;\r\n    };\r\n\r\n    delete = async (key: string) => {\r\n        await this._pLimit(() => this._actor.delete_content({key}));\r\n        this._eventListener({key, type: 'delete'});\r\n    }\r\n}","import {idlFactory} from './asset_canister.did.js';\r\nimport {Actor} from \"@dfinity/agent\";\r\n\r\n/**\r\n * @type {(configuration: import(\"@dfinity/agent\").ActorConfig) => import(\"@dfinity/agent\").ActorSubclass<import(\"./asset_canister.did.js\")._SERVICE>}\r\n */\r\nexport const assetCanister = (configuration) => Actor.createActor(idlFactory, configuration);\r\n"],"names":["IDL","ClearArguments","Record","BatchId","Nat","Key","Text","CreateAssetArguments","key","content_type","UnsetAssetContentArguments","content_encoding","DeleteAssetArguments","ChunkId","SetAssetContentArguments","sha256","Opt","Vec","Nat8","chunk_ids","BatchOperationKind","Variant","CreateAsset","UnsetAssetContent","DeleteAsset","SetAssetContent","Clear","HeaderField","Tuple","url","method","body","headers","StreamingCallbackToken","index","token","Callback","callback","Func","StreamingCallbackHttpResponse","HttpResponse","streaming_strategy","StreamingStrategy","status_code","Nat16","Time","Int","Service","authorize","Principal","clear","commit_batch","batch_id","operations","create_asset","create_batch","create_chunk","content","chunk_id","delete_content","get","accept_encodings","total_length","get_chunk","http_request","HttpRequest","http_request_streaming_callback","list","encodings","modified","length","set_asset_content","store","unset_asset_content","_excluded","isBrowser","window","document","isNode","process","versions","node","isWebWorker","self","constructor","name","crypto","Promise","resolve","import","inputToAsset","async","input","options","_options$path","_options$contentEncod","_options$sha","fileName","contentType","path","Uint8Array","Array","from","isArray","every","b","Blob","reader","addEventListener","result","readAsArrayBuffer","File","type","startsWith","endsWith","contentEncoding","subtle","digest","createHash","update","hash","_await$fileTypeFromBu","mime","fileTypeFromBuffer","AssetManager","_ref","_this","this","concurrency","maxSingleFileSize","maxChunkSize","eventListener","actorConfig","_actor","_pLimit","_maxSingleFileSize","_maxChunkSize","_eventListener","batch","scheduledOperations","commit","all","map","scheduled_operation","flat","forEach","operation","insert","asset","join","progress","current","total","push","chunks","reduce","byte","chunkIndex","Math","floor","chunkIds","chunk","delete","Actor","createActor","idlFactory","pLimit"],"mappings":"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"}